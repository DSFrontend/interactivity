# Подходы к интерактивности

## Основные понятия

Интерактивность -- это способность страницы реагировать на действия пользователя.
Хотя в более широком смысле интерактивность это любое взаимодействие между объектами.

Существует такое понятие как уровни интерактивность: это степень интегрированности возбудителей 
к реакциям системы. Выделяют 3 уровня интерактивности:

1. линейный(1:) -- возбудители никак не влияют на поведение системы
2. реактивный(1:1) -- только последний возбудитель берется в учет
3. диалоговый(1:n) -- все предыдущие возбудители образуют контекст

А теперь мы делаем плавный переход к нашей теме с точки зрения веб-разработки. Давайте немного 
разберемся, как эта теоретическая часть ложится на нашу работу?

## Интерактивность с точки зрения веба

Мы все знакомы с понятием время до интерактивности, оно же time to interactive, оно же TTI.

Для тех, кто не знаком я объясню, а для забывших напомню.

Время до интерактивности -- это метрика, позволяющая определить производительность веб страницы,
и заключается в измерении времени между событиями **пользователь запросил страницу** и 
**пользователь может на странице что-то сделать**

Но вот это **пользователь может на странице что-то сделать** очень неформально. Это часто 
конкретизируют следующими параметрами:

1. Большинство ресурсов страницы загружены
2. Основные визуальные элементы отрендерены
3. Основной поток обработки событий не заблокирован более чем на 50мс

Последний момент довольно важен, потому что первые два могут уже случиться, но наш код начинает 
выполнять какую-то тяжелую операцию (инициализацию большой библиотеки, загрузка большого массива 
данных и т.д.),что может заблокировать поток выполнения и оттягивать момент до интерактивности. 
Возможно вы видели сообщения в консоли разработчика подобные варнинги:

```
[Violation] Long running JavaScript task took 234ms
[Violation] Forced reflow while executing JavaScript took 45ms
[Violation] Handler took 231ms of runtime (50ms allowed)
```

Они как раз о том, что обработчик события задумался.

TTI состоит из еще нескольких метрик под собой:

- TTFB -- time to first byte -- время ожидания между нажатием на ссылку и получением первого бита
- FP -- first paint -- время до рендеринга первого пикселя
- FCP -- first contentful paint -- время до показа контента

Но возвращаясь к теоретической части, как те уровни ложатся на TTI?

Легко можно понять, что линейный уровень интерактивности соответствует загрузке веб страницы, 
реактивный прикреплению слушателей событий, а диалоговой -- восстановлению состояния сессии.

И на все из них мы можем повлиять в той или иной степени. Давайте рассмотрим, какие подходы к 
интерактивности существуют, как они себя проявляют и что там с TTI?

## Подходы к интерактивности

Сначала давайте проясним, что же такое гидрация.

Гидрация -- это процесс добавления слушателей событий к HTML.

Итак, какие у нас есть подходы к интерактивности:

### Multi page rendering

Серверный рендеринг -- подход, при котором сервер отдает готовую страницу, наполненную контентом, но 
не интерактивную, за исключением HTML-way interactivity (ссылки, формы, стандартные компоненты).

Плюсы:
- контент видно сразу
Минусы
- серверу требуется некоторое время, чтобы отрендерить страницу

Фреймворки, которые это реализуют:
- Ruby on rails
- Laravel
- Django
- WordPress

### Client side rendering

Клиентский рендеринг -- у нас есть маленький HTML и огромный бандл, который мы поставляем в браузер, 
и этот бандл отрисовывает страницу целиком и поддерживает её в актуальном состоянии

Плюсы:
- хороший UX: все обновляется сразу
Минусы:
- большой бандл и огромный рантайм
- плохая интеграция с поисковыми роботами

Фреймворки, которые это реализуют:
- Angular
- React
- Vue
- and so on...

### Hybrid rendering / SSR

Гибридный рендеринг -- это выдача статического предподготовленного HTML в браузера с последующей 
гидрацией

Плюсы:
- лучшее из SSR и CSR: контент сразу, обновления, поисковые роботы
Минусы:
- Нужен сервер, а не просто что-то, что умеет отдавать файлы

Фреймворки, которые это реализуют:
Многие мета-фреймворки
- Next.js
- Nuxt.js

### Partial hydration

Частичная гидрация -- подход, при котором некоторый маленький рантайм динамически определяет, 
что сейчас должно быть интерактивно

Минусы:
- Этот умный рантайм должен быть кем-то написан

Фреймворки, которые это реализуют:
- Astro

### Islands

Острова интерактивности -- способ рендеринга, который разделяет статический и интерактивный контент, 
и совершать гидратацию гранулярно: только там, где требуется

Фреймворки, которые это реализуют:
- fresh

### Resumability

Resumability -- подход, при котором страница рендерится на сервере, в неё сериализуют состояние 
приложения, а весь необходимый js разбивается на минимальные чанки и прилетает по требованию

Плюсы:
- 0 JS on first load
- контент виден сразу
Минусы:
- более сложная архитектура приложения

Фреймворки, которые это реализуют:
- Qwik


Есть еще как минимум 4 подхода, среди которых:
- static site
- static site generation with hydration
- incremental static render
- SSR streaming

Они либо не укладываются или слабо укладываются в понятие интерактивности, либо являются уточнением 
уже описанного метода
